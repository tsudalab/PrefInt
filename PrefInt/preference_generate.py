# Copyright (C) 2020 by Xiaolin Sun
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

# This includes all pair generated by the y data. For example, if your data set is 1,3,2,4, 
# the preference is 4>3,4>2,4>1,3>2,3>1,2>1
# the number of pairs should be n = m(m-1)/2


import pandas as pd
import numpy as np
"""

Arguements:
----------  
training_data: array-like, shape = [X,y]

X: array-like, shape = [n_samples, f_features]
    The input to the Gaussian Process
y: array-like, shape = [n_samples, 1]
    Latent function values
    """

class generate_pair():

    def __init__(self, training_data):
        self.training_data = training_data.copy()


    def firstgen (self):

        self.prefs = list()
        
        n,f = self.training_data.shape[0],self.training_data.shape[1]
        X,y = self.training_data[:,:f-1], self.training_data[:,-1]

        for i in range (0,n-1):
            for j in range (0,n-i-1):
                if y[i] - y[i+j+1] > 0: 
                    d = 1
                    self.prefs.append((X[i],X[i+j+1],1))
       
                #else:
                #    if i == 0 and j == 0:
                     
                #        self.prefs.append ((X[i],X[i+j+1],0))
                else:
                    self.prefs.append((X[i+j+1],X[i],1))

                #prefs.append((X[i],X[i+j+1],d))

        return self.prefs

    def addnew(self,newdata):
        
        n,f = self.training_data.shape[0],self.training_data.shape[1]
        X,self.y = self.training_data[:,:f-1], self.training_data[:,-1]
        
        newdata = newdata.reshape(1,f)

        self.newprefs = list()

        a,b = newdata[0,:-1],newdata[0,-1]
        for i in range(0,n):
            if b - self.y[i] >= 0:
                d = 1
                self.newprefs.append((a,X[i],1))
            else:
                self.newprefs.append((X[i],a,1))

        self.training_data = np.r_[self.training_data,newdata]
        #self.n = self.training_data.shape[0]
        
        #self.n,self.f = self.training_data.shape[0],self.training_data.shape[1]
        #self.X,self.y = self.training_data[:,:self.f-1], self.training_data[:,-1]

        #self.prefs = np.r_[self.prefs,self.newprefs]

        return self.newprefs









